<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>粉色粒子圣诞树</title>
    <style>
        body {
            margin: 0;
            background-color: #1F0F12;
            /* 对应原代码 Style 6 背景 */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.1);
        }
    </style>
</head>

<body>

    <canvas id="treeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        // 样式配置
        const cfg = {
            bg_col: "#1F0F12",
            tree_cols: ["#D87093", "#FF69B4", "#FFB6C1"],
            trunk_col: "#4A3728",
            star_col: "#FFD700",
            text_col: "#FFC0CB",
            snow_col: "#FFF0F5",
            ribbon_col: "#FFFFFF" // 要求的白色粒子线
        };

        const width = 600;
        const height = 750;
        canvas.width = width;
        canvas.height = height;

        let particles = [];
        let snowflakes = [];
        let angle = 0;

        // --- 1. 生成粒子数据 (逻辑复刻自原 R 代码) ---
        function initData() {
            particles = [];

            // 生成树干粒子 (棕色)
            for (let i = 0; i < 1000; i++) {
                const h = Math.random() * 0.25 - 0.7;
                const r = Math.random() * 0.12;
                const theta = Math.random() * Math.PI * 2;
                particles.push({ x: r * Math.cos(theta), y: h, z: r * Math.sin(theta), col: cfg.trunk_col, size: 1.2, type: 'trunk' });
            }

            // 生成树叶粒子 (粉色多层圆锥)
            const n_layers = 7;
            for (let i = 0; i < 8000; i++) {
                const h = Math.random();
                const base_r = (1 - h);
                const layer_cycle = (h * n_layers) % 1;
                const r = base_r * 0.65 * (0.4 + 0.6 * Math.pow(1 - layer_cycle, 0.7));
                const theta = Math.random() * Math.PI * 2;
                const col = cfg.tree_cols[Math.floor(Math.random() * cfg.tree_cols.length)];
                particles.push({ x: r * Math.cos(theta), y: h - 0.5, z: r * Math.sin(theta), col: col, size: Math.random() * 1.2 + 0.6, type: 'leaf' });
            }

            // 生成白色环绕线粒子 (白色丝带)
            for (let i = 0; i < 4000; i++) {
                const h = (i / 4000) * 0.95;
                const r = (1 - h) * 0.65 * 1.05;
                const theta = 10 * Math.PI * h;
                particles.push({ x: r * Math.cos(theta), y: h - 0.5, z: r * Math.sin(theta), col: cfg.ribbon_col, size: 0.9, type: 'ribbon' });
            }

            // 生成雪花
            for (let i = 0; i < 200; i++) {
                snowflakes.push({ x: Math.random() * 2 - 1, y: Math.random() * 2 - 0.8, z: Math.random() * 2 - 1, speed: Math.random() * 0.005 + 0.005 });
            }
        }

        // --- 2. 3D 投影转换 ---
        function project(p, rotateAngle) {
            const cosA = Math.cos(rotateAngle);
            const sinA = Math.sin(rotateAngle);

            // Y 轴旋转坐标变换
            const xRot = p.x * cosA - p.z * sinA;
            const zRot = p.z * cosA + p.x * sinA;

            // 模拟 R 代码深度 depth = 1 / (2.5 - z_rot)
            const depth = 1 / (2.5 - zRot);

            return {
                x2d: xRot * depth * 800 + width / 2,
                y2d: -p.y * depth * 800 + height * 0.55,
                size: (p.size || 1) * depth * 3,
                alpha: (zRot + 1.2) / 2.2,
                z: zRot
            };
        }

        // --- 3. 绘制五角星 (树顶) ---
        function drawStar(angle) {
            const starPos = project({ x: 0, y: 0.52, z: 0 }, angle);
            const r = 18;
            ctx.save();
            ctx.translate(starPos.x2d, starPos.y2d);
            ctx.beginPath();
            ctx.fillStyle = cfg.star_col;
            ctx.shadowBlur = 20;
            ctx.shadowColor = "white";
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * r, -Math.sin((18 + i * 72) / 180 * Math.PI) * r);
                ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * (r / 2), -Math.sin((54 + i * 72) / 180 * Math.PI) * (r / 2));
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // --- 4. 动画循环 ---
        function render() {
            ctx.fillStyle = cfg.bg_col;
            ctx.fillRect(0, 0, width, height);

            angle += 0.02;

            // 绘制雪花-点
            ctx.fillStyle = cfg.snow_col;
            snowflakes.forEach(s => {
                s.y -= s.speed;
                if (s.y < -0.8) s.y = 1.2;
                const p = project({ x: s.x, y: s.y, z: s.z, size: 1.5 }, 0);
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(p.x2d, p.y2d, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // 绘制雪花-❆
            // ctx.fillStyle = cfg.snow_col;
            // snowflakes.forEach(s => {
            //     s.y -= s.speed;
            //     if (s.y < -0.8) s.y = 1.2;
            //     const p = project({ x: s.x, y: s.y, z: s.z, size: 0.5 }, 0);
            //     ctx.globalAlpha = 0.6;
            //     ctx.font = `${p.size * 12}px Arial`;
            //     ctx.textAlign = 'center';
            //     ctx.textBaseline = 'middle';
            //     ctx.fillText('❆', p.x2d, p.y2d);
            // });

            // 粒子排序 (Painter's Algorithm 实现遮挡)
            let renderQueue = particles.map(p => ({ ...p, ...project(p, angle) }));
            renderQueue.sort((a, b) => a.z - b.z);

            // 绘制粒子
            renderQueue.forEach(p => {
                ctx.globalAlpha = Math.max(0, p.alpha);
                ctx.fillStyle = p.col;
                ctx.beginPath();
                ctx.arc(p.x2d, p.y2d, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            drawStar(angle);

            // 绘制标题
            ctx.globalAlpha = 1;
            ctx.fillStyle = cfg.text_col;
            ctx.font = "italic 42px 'Times New Roman', serif";
            ctx.textAlign = "center";
            ctx.fillText("Merry Christmas", width / 2, height * 0.9);

            requestAnimationFrame(render);
        }

        initData();
        render();

    </script>
</body>

</html>